<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="mobile-web-app-capable" content="yes">
  <title>NeoFermi</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }

    html, body {
      height: 100%;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background: #1e1e1e;
      color: #d4d4d4;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #252525;
      padding: 12px 16px;
      border-bottom: 1px solid #3e3e3e;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    h1 {
      font-size: 18px;
      font-weight: 600;
      color: #ffffff;
    }

    .subtitle {
      font-size: 11px;
      color: #888;
      display: none;
    }

    @media (min-width: 480px) {
      .subtitle { display: inline; }
    }

    .header-actions {
      display: flex;
      gap: 8px;
    }

    .header-btn {
      background: #3e3e3e;
      color: #d4d4d4;
      border: none;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 12px;
      cursor: pointer;
      touch-action: manipulation;
    }

    .header-btn:active {
      background: #4e4e4e;
    }

    .header-btn.active {
      background: #007acc;
      color: white;
    }

    /* Export dropdown */
    .export-dropdown {
      position: relative;
      display: inline-block;
    }

    .export-menu {
      display: none;
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 4px;
      background: #2d2d2d;
      border: 1px solid #4e4e4e;
      border-radius: 6px;
      min-width: 120px;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }

    .export-menu.visible {
      display: block;
    }

    .export-option {
      display: block;
      width: 100%;
      padding: 8px 12px;
      background: transparent;
      border: none;
      color: #d4d4d4;
      font-size: 12px;
      text-align: left;
      cursor: pointer;
    }

    .export-option:hover {
      background: #3e3e3e;
    }

    .export-option:first-child {
      border-radius: 5px 5px 0 0;
    }

    .export-option:last-child {
      border-radius: 0 0 5px 5px;
    }

    #notebook {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      -webkit-overflow-scrolling: touch;
    }

    .cell {
      background: #252525;
      border-radius: 8px;
      margin-bottom: 12px;
      border: 1px solid #3e3e3e;
      overflow: hidden;
    }

    .cell.focused {
      border-color: #007acc;
    }

    .cell-header {
      display: flex;
      align-items: center;
      padding: 6px 12px;
      background: #2d2d2d;
      border-bottom: 1px solid #3e3e3e;
      gap: 8px;
    }

    .cell-num {
      color: #888;
      font-size: 11px;
      font-weight: 500;
      min-width: 24px;
    }

    .cell-actions {
      margin-left: auto;
      display: flex;
      gap: 4px;
    }

    .cell-btn {
      background: transparent;
      border: none;
      color: #888;
      padding: 4px 8px;
      font-size: 12px;
      cursor: pointer;
      border-radius: 4px;
    }

    .cell-btn:hover {
      background: #3e3e3e;
      color: #d4d4d4;
    }

    .cell-btn.run {
      color: #4ec9b0;
    }

    .cell-btn.delete {
      color: #f48771;
    }

    .cell-input {
      width: 100%;
      background: transparent;
      border: none;
      color: #d4d4d4;
      padding: 12px;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      font-size: 14px;
      line-height: 1.5;
      resize: none;
      outline: none;
      min-height: 40px;
    }

    .cell-input::placeholder {
      color: #666;
    }

    /* Autocomplete dropdown */
    .autocomplete-container {
      position: relative;
    }

    .autocomplete-dropdown {
      position: absolute;
      left: 12px;
      background: #2d2d2d;
      border: 1px solid #4e4e4e;
      border-radius: 6px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      min-width: 200px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }

    .autocomplete-dropdown.visible {
      display: block;
    }

    .autocomplete-item {
      padding: 6px 10px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
    }

    .autocomplete-item:hover,
    .autocomplete-item.selected {
      background: #3e3e3e;
    }

    .autocomplete-item .label {
      color: #d4d4d4;
      font-weight: 500;
    }

    .autocomplete-item .type {
      color: #888;
      font-size: 10px;
      padding: 1px 4px;
      background: #3e3e3e;
      border-radius: 3px;
    }

    .autocomplete-item .type.function { color: #dcdcaa; background: #3e3e3e; }
    .autocomplete-item .type.constant { color: #4fc1ff; background: #3e3e3e; }
    .autocomplete-item .type.unit { color: #4ec9b0; background: #3e3e3e; }
    .autocomplete-item .type.keyword { color: #c586c0; background: #3e3e3e; }

    .autocomplete-item .desc {
      color: #666;
      font-size: 11px;
      margin-left: auto;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 150px;
    }

    .cell-output {
      border-top: 1px solid #3e3e3e;
      padding: 12px;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      font-size: 13px;
      line-height: 1.5;
      display: none;
    }

    .cell-output.visible {
      display: block;
    }

    .cell-output.error {
      color: #f48771;
      background: rgba(244, 135, 113, 0.1);
    }

    .cell-output.result {
      color: #ce9178;
      background: rgba(206, 145, 120, 0.08);
    }

    .result-stats {
      white-space: pre-wrap;
      word-break: break-word;
    }

    .result-viz {
      margin-top: 12px;
      display: flex;
      justify-content: center;
    }

    .result-viz canvas {
      border-radius: 4px;
    }

    .dim-name {
      color: #888;
      font-style: italic;
    }

    #add-cell-btn {
      width: 100%;
      padding: 12px;
      background: transparent;
      border: 2px dashed #3e3e3e;
      border-radius: 8px;
      color: #666;
      font-size: 14px;
      cursor: pointer;
      margin-bottom: 16px;
    }

    #add-cell-btn:hover {
      border-color: #007acc;
      color: #007acc;
    }

    .examples-banner {
      background: #2d2d2d;
      padding: 12px 16px;
      margin-bottom: 16px;
      border-radius: 8px;
      border-left: 3px solid #007acc;
    }

    .examples-banner h3 {
      font-size: 13px;
      color: #4ec9b0;
      margin-bottom: 8px;
    }

    .example-chips {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .example-chip {
      background: rgba(0, 0, 0, 0.3);
      border: none;
      color: #ce9178;
      padding: 6px 10px;
      border-radius: 4px;
      font-size: 12px;
      font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
      cursor: pointer;
    }

    .example-chip:active {
      background: rgba(0, 122, 204, 0.3);
    }

    .footer-bar {
      background: #252525;
      border-top: 1px solid #3e3e3e;
      padding: 8px 16px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      flex-shrink: 0;
    }

    .viz-toggle {
      display: flex;
      gap: 4px;
    }

    .status {
      font-size: 11px;
      color: #666;
    }

    /* Help modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      padding: 16px;
    }

    .modal-overlay.visible {
      display: flex;
    }

    .modal {
      background: #2d2d2d;
      border-radius: 12px;
      max-width: 500px;
      max-height: 80vh;
      overflow-y: auto;
      width: 100%;
    }

    .modal-header {
      padding: 16px;
      border-bottom: 1px solid #3e3e3e;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .modal-header h2 {
      font-size: 16px;
      color: #fff;
    }

    .modal-close {
      background: none;
      border: none;
      color: #888;
      font-size: 20px;
      cursor: pointer;
      padding: 4px 8px;
    }

    .modal-body {
      padding: 16px;
      font-size: 13px;
      line-height: 1.6;
      color: #d4d4d4;
    }

    .modal-body h4 {
      color: #4ec9b0;
      margin-top: 16px;
      margin-bottom: 8px;
    }

    .modal-body h4:first-child {
      margin-top: 0;
    }

    .modal-body code {
      background: rgba(0, 0, 0, 0.3);
      padding: 2px 6px;
      border-radius: 3px;
      color: #ce9178;
    }

    .modal-body pre {
      background: rgba(0, 0, 0, 0.3);
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
      margin: 8px 0;
    }
  </style>
</head>
<body>
  <header>
    <div class="header-left">
      <h1>NeoFermi</h1>
      <span class="subtitle">Monte Carlo calculator</span>
    </div>
    <div class="header-actions">
      <button class="header-btn" id="help-btn">Help</button>
      <button class="header-btn" id="share-btn">Share</button>
      <button class="header-btn" id="import-btn">Import</button>
      <input type="file" id="import-file" accept=".json,.md,.txt" style="display:none">
      <div class="export-dropdown">
        <button class="header-btn" id="export-btn">Export</button>
        <div class="export-menu" id="export-menu">
          <button class="export-option" data-format="text">Plain Text</button>
          <button class="export-option" data-format="markdown">Markdown</button>
          <button class="export-option" data-format="json">JSON</button>
        </div>
      </div>
      <button class="header-btn" id="run-all-btn">Run All</button>
      <button class="header-btn" id="clear-btn">Clear</button>
    </div>
  </header>

  <div id="notebook">
    <div class="examples-banner" id="examples-banner">
      <h3>Try these examples:</h3>
      <div class="example-chips">
        <button class="example-chip" data-code="10 to 100 meters">10 to 100 meters</button>
        <button class="example-chip" data-code="x = 1 to 1000 kg">x = 1 to 1000 kg</button>
        <button class="example-chip" data-code="outof(7, 10)">outof(7, 10)</button>
        <button class="example-chip" data-code="100 meters as feet">100 meters as feet</button>
      </div>
    </div>

    <div id="cells"></div>

    <button id="add-cell-btn">+ Add Cell</button>
  </div>

  <div class="footer-bar">
    <div class="viz-toggle">
      <button class="header-btn active" data-viz="dotplot">Dots</button>
      <button class="header-btn" data-viz="histogram">Hist</button>
    </div>
    <div class="status" id="status">Ready</div>
  </div>

  <!-- Help Modal -->
  <div class="modal-overlay" id="help-modal">
    <div class="modal">
      <div class="modal-header">
        <h2>NeoFermi Help</h2>
        <button class="modal-close" id="close-help">&times;</button>
      </div>
      <div class="modal-body">
        <h4>Distribution Syntax</h4>
        <pre>1 to 10 m            # Lognormal (68% CI)
1 .. 10 m            # Uniform distribution
1 thru 10 m          # Uniform (alternate)
100 +- 5 kg          # Normal (mean ± sigma)
100 pm 5 kg          # Normal (alternate)
3 of 10              # Beta (3 successes, 10 trials)
3 against 7          # Beta (3 wins, 7 losses)
{365, 366} day       # Equal-weighted set
{365: 303, 366: 97}  # Weighted set (dict-style)
100 * 10%            # Twiddle by ±10%
100 * 0db            # Twiddle by factor of 2
100 * -10db          # Twiddle by order of magnitude</pre>

        <h4>Sig-Fig Numbers</h4>
        <pre>'3.14                # Uniform(3.135, 3.145)
'130                 # Uniform(125, 135)
'130.                # Uniform(129.5, 130.5)
'1.3e6 m             # With units</pre>

        <h4>Unit Conversion</h4>
        <pre>100 meters as feet   # Convert to specific unit
x -> km              # Alternative syntax
100 miles as SI      # Convert to SI base units</pre>

        <p style="margin-top: 8px; color: #888; font-size: 11px;">
          Results are displayed in SI units by default.
        </p>

        <h4>Variables</h4>
        <pre>x = 10 to 100 meters
y = x * 2
area = x * y</pre>

        <h4>Distribution Functions</h4>
        <pre>lognormal(1, 100)    # Positive values
normal(-10, 10)      # Any values
uniform(0, 1)        # Flat distribution
outof(7, 10)         # Beta for proportions
gamma(2, 5)          # Shape/scale parameters
poisson(5)           # Count data (events)
exponential(0.5)     # Waiting times (rate)
binomial(10, 0.5)    # n trials, p success</pre>

        <h4>Operators &amp; Comments</h4>
        <code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>^</code> &nbsp; <code># comment</code>

        <h4>Custom Units</h4>
        <code>100 'widgets</code> (tick prefix for custom units)

        <h4>Physical Constants</h4>
        <pre>c, h, hbar, e, k, G  # Fundamentals
M_earth, R_earth     # Earth (with uncertainty)
M_sun, R_sun, L_sun  # Solar
year, month, day     # Time (year/month are distributions)
AU, ly, pc           # Distances</pre>

        <h4>Keyboard Shortcuts</h4>
        <pre>Shift+Enter          # Run current cell
Ctrl/Cmd+Enter       # Run all cells
Ctrl/Cmd+S           # Export as JSON
Ctrl/Cmd+O           # Import file
Ctrl/Cmd+N           # New cell
Escape               # Unfocus cell</pre>
      </div>
    </div>
  </div>

  <script type="module">
    import { parse, Evaluator } from './src/parser/index.js'
    import { visualize } from './src/visualization/index.js'
    import { getCompletions, getWordAtCursor } from './src/autocomplete/index.js'


    // State
    let cells = []
    let vizType = 'dotplot'
    const evaluator = new Evaluator()
    const STORAGE_KEY = 'neofermi-notebook'
    const DEBOUNCE_MS = 500

    // DOM elements
    const cellsContainer = document.getElementById('cells')
    const addCellBtn = document.getElementById('add-cell-btn')
    const statusEl = document.getElementById('status')
    const examplesBanner = document.getElementById('examples-banner')

    // =====================
    // Cell Management
    // =====================

    function createCell(code = '', id = null) {
      const cellId = id || Date.now().toString(36) + Math.random().toString(36).substr(2)
      const cell = { id: cellId, code, result: null, error: null }
      cells.push(cell)
      renderCell(cell)
      saveToStorage()
      updateStatus()
      return cell
    }

    function deleteCell(id) {
      const index = cells.findIndex(c => c.id === id)
      if (index === -1) return
      cells.splice(index, 1)
      document.getElementById(`cell-${id}`)?.remove()
      saveToStorage()
      updateCellNumbers()
      updateStatus()
    }

    function updateCellCode(id, code) {
      const cell = cells.find(c => c.id === id)
      if (cell) {
        cell.code = code
        saveToStorage()
      }
    }

    function updateCellNumbers() {
      cells.forEach((cell, i) => {
        const numEl = document.querySelector(`#cell-${cell.id} .cell-num`)
        if (numEl) numEl.textContent = `[${i + 1}]`
      })
    }

    // =====================
    // Rendering
    // =====================

    function renderCell(cell) {
      const index = cells.indexOf(cell)
      const el = document.createElement('div')
      el.className = 'cell'
      el.id = `cell-${cell.id}`

      el.innerHTML = `
        <div class="cell-header">
          <span class="cell-num">[${index + 1}]</span>
          <div class="cell-actions">
            <button class="cell-btn run" title="Run">▶</button>
            <button class="cell-btn delete" title="Delete">✕</button>
          </div>
        </div>
        <div class="autocomplete-container">
          <textarea class="cell-input" placeholder="Enter expression..." rows="1">${escapeHtml(cell.code)}</textarea>
          <div class="autocomplete-dropdown"></div>
        </div>
        <div class="cell-output"></div>
      `

      const textarea = el.querySelector('.cell-input')
      const output = el.querySelector('.cell-output')
      const dropdown = el.querySelector('.autocomplete-dropdown')

      // Autocomplete state for this cell
      let acState = { visible: false, items: [], selectedIndex: 0, wordInfo: null }

      // Auto-resize textarea
      const autoResize = () => {
        textarea.style.height = 'auto'
        textarea.style.height = textarea.scrollHeight + 'px'
      }

      // Autocomplete functions
      function showAutocomplete() {
        const wordInfo = getWordAtCursor(textarea.value, textarea.selectionStart)
        if (!wordInfo || wordInfo.word.length < 2) {
          hideAutocomplete()
          return
        }

        const items = getCompletions(wordInfo.word, 8)
        if (items.length === 0) {
          hideAutocomplete()
          return
        }

        acState = { visible: true, items, selectedIndex: 0, wordInfo }
        renderAutocomplete()
      }

      function hideAutocomplete() {
        acState.visible = false
        dropdown.classList.remove('visible')
      }

      function renderAutocomplete() {
        if (!acState.visible) return
        dropdown.innerHTML = acState.items.map((item, i) => `
          <div class="autocomplete-item ${i === acState.selectedIndex ? 'selected' : ''}" data-index="${i}">
            <span class="label">${item.label}</span>
            <span class="type ${item.type}">${item.type}</span>
            ${item.description ? `<span class="desc">${item.description}</span>` : ''}
          </div>
        `).join('')
        dropdown.classList.add('visible')

        // Click handlers for items
        dropdown.querySelectorAll('.autocomplete-item').forEach(itemEl => {
          itemEl.addEventListener('mousedown', (e) => {
            e.preventDefault()
            const idx = parseInt(itemEl.dataset.index)
            selectAutocompleteItem(idx)
          })
        })
      }

      function selectAutocompleteItem(index) {
        if (!acState.visible || !acState.wordInfo) return
        const item = acState.items[index]
        if (!item) return

        const { start, end } = acState.wordInfo
        const before = textarea.value.slice(0, start)
        const after = textarea.value.slice(end)
        const newValue = before + item.label + after
        textarea.value = newValue
        textarea.selectionStart = textarea.selectionEnd = start + item.label.length

        updateCellCode(cell.id, newValue)
        hideAutocomplete()
        textarea.focus()
      }

      // Debounced evaluation
      let debounceTimer = null
      textarea.addEventListener('input', () => {
        autoResize()
        updateCellCode(cell.id, textarea.value)

        // Show autocomplete
        showAutocomplete()

        clearTimeout(debounceTimer)
        debounceTimer = setTimeout(() => {
          runCell(cell.id)
        }, DEBOUNCE_MS)
      })

      // Focus handling
      textarea.addEventListener('focus', () => {
        el.classList.add('focused')
      })

      // Keyboard handling (autocomplete navigation + run)
      textarea.addEventListener('keydown', (e) => {
        // Autocomplete navigation
        if (acState.visible) {
          if (e.key === 'ArrowDown') {
            e.preventDefault()
            acState.selectedIndex = (acState.selectedIndex + 1) % acState.items.length
            renderAutocomplete()
            return
          }
          if (e.key === 'ArrowUp') {
            e.preventDefault()
            acState.selectedIndex = (acState.selectedIndex - 1 + acState.items.length) % acState.items.length
            renderAutocomplete()
            return
          }
          if (e.key === 'Enter' || e.key === 'Tab') {
            e.preventDefault()
            selectAutocompleteItem(acState.selectedIndex)
            return
          }
          if (e.key === 'Escape') {
            e.preventDefault()
            hideAutocomplete()
            return
          }
        }

        // Run on Shift+Enter
        if (e.key === 'Enter' && e.shiftKey) {
          e.preventDefault()
          clearTimeout(debounceTimer)
          runCell(cell.id)
        }
      })

      // Hide autocomplete on blur (with delay for click to register)
      textarea.addEventListener('blur', () => {
        el.classList.remove('focused')
        setTimeout(hideAutocomplete, 150)
      })

      // Button handlers
      el.querySelector('.cell-btn.run').addEventListener('click', () => {
        clearTimeout(debounceTimer)
        runCell(cell.id)
      })
      el.querySelector('.cell-btn.delete').addEventListener('click', () => {
        deleteCell(cell.id)
      })

      cellsContainer.appendChild(el)
      autoResize()

      // If cell has result, render it
      if (cell.result || cell.error) {
        renderOutput(cell)
      }
    }

    function renderOutput(cell) {
      const el = document.getElementById(`cell-${cell.id}`)
      if (!el) return

      const output = el.querySelector('.cell-output')
      output.innerHTML = ''
      output.classList.remove('visible', 'error', 'result')

      if (cell.error) {
        output.classList.add('visible', 'error')
        output.textContent = `Error: ${cell.error}`
        return
      }

      if (cell.result !== null && cell.result !== undefined) {
        output.classList.add('visible', 'result')

        try {
          const q = cell.result
          if (q && typeof q === 'object' && q.isDistribution && q.isDistribution()) {
            // Distribution result - convert to SI for display
            const qSI = q.toSI ? q.toSI() : q

            const stats = document.createElement('div')
            stats.className = 'result-stats'
            stats.innerHTML = formatQuantity(q, true)
            output.appendChild(stats)

            // Visualization (use SI-converted data)
            const vizContainer = document.createElement('div')
            vizContainer.className = 'result-viz'
            const width = Math.min(window.innerWidth - 80, 280)
            const canvas = visualize(qSI, vizType, {
              width,
              height: 105, // Increased to accommodate axis label
              numDots: 20,
              numBins: 25,
              dotColor: '#4ec9b0',
              barColor: '#4ec9b0',
            })
            if (canvas) {
              vizContainer.appendChild(canvas)
              output.appendChild(vizContainer)
            }
          } else if (q && typeof q === 'object' && q.isScalar && q.isScalar()) {
            // Scalar result - convert to SI for display
            const qSI = q.toSI ? q.toSI() : q
            const unit = qSI.unit.toString()
            const dimName = qSI.dimensionName ? qSI.dimensionName() : null
            const valueStr = cleanFloatArtifacts(qSI.value)
            if (dimName && dimName !== 'dimensionless') {
              output.innerHTML = `${valueStr} ${unit} <span class="dim-name">{${dimName}}</span>`
            } else {
              output.textContent = `${valueStr} ${unit}`
            }
          } else {
            // Other result
            output.textContent = String(q)
          }
        } catch (renderErr) {
          output.classList.add('error')
          output.textContent = `Render error: ${renderErr.message}`
        }
      }
    }

    /**
     * Clean up floating point artifacts while preserving meaningful precision
     * e.g., "0.30000000000000004" -> "0.3"
     * e.g., "0.29999999999999999" -> "0.3"
     * But preserves real precision like "3.14159265359"
     */
    function cleanFloatArtifacts(value) {
      if (!isFinite(value) || value === 0) {
        return String(value)
      }

      const str = String(value)

      // Check for floating point noise patterns: many 0s or 9s near the end
      // Pattern: digits followed by 0000+ or 9999+ with maybe 1-2 other digits
      if (/\d\.(.*)(0000\d{0,2}|9999\d{0,2})$/.test(str)) {
        // Round to 10 significant figures to clean up artifacts
        const rounded = parseFloat(value.toPrecision(10))
        return String(rounded)
      }

      return str
    }

    /**
     * Format a number with a maximum number of significant figures
     * Used when we want to limit precision (e.g., for uncertain values)
     */
    function formatToSigFigs(value, maxSigFigs) {
      if (!isFinite(value) || value === 0) {
        return String(value)
      }

      const absValue = Math.abs(value)

      // Use scientific notation for very large or small numbers
      if (absValue >= 1e6 || (absValue < 1e-3 && absValue > 0)) {
        return value.toExponential(Math.min(maxSigFigs - 1, 4))
      }

      // Use toPrecision and clean up
      let str = value.toPrecision(maxSigFigs)
      const parsed = parseFloat(str)

      // Remove unnecessary trailing zeros after decimal
      str = String(parsed)

      return str
    }

    /**
     * Format a number with significant figures based on uncertainty
     * Shows only as many digits as justified by the uncertainty
     */
    function formatWithUncertainty(value, uncertainty) {
      if (uncertainty === 0 || !isFinite(uncertainty)) {
        // No uncertainty info - just clean up float artifacts
        return cleanFloatArtifacts(value)
      }

      // Calculate significant figures from relative uncertainty
      const relUncertainty = Math.abs(uncertainty / value)

      // Number of significant figures = -log10(relative uncertainty)
      // But at least 2 and at most 5 for uncertain values
      let sigFigs = Math.max(2, Math.min(5, Math.ceil(-Math.log10(relUncertainty))))

      // For very uncertain values (>30% relative), use 1-2 sig figs
      if (relUncertainty > 0.3) {
        sigFigs = 2
      }

      return formatToSigFigs(value, sigFigs)
    }

    function formatQuantity(q, asHtml = false) {
      // Convert to SI units by default for consistent display
      const qSI = q.toSI ? q.toSI() : q

      const mean = qSI.mean()
      const median = qSI.median()
      const p16 = qSI.percentile(0.16)
      const p84 = qSI.percentile(0.84)

      // Calculate uncertainty as half-width of 68% CI
      const uncertainty = (p84 - p16) / 2

      // Get unit and dimension name
      const unit = qSI.unit.toString()
      const dimName = qSI.dimensionName ? qSI.dimensionName() : null

      // Format unit string with dimension name
      let unitStr = unit
      let unitStrPlain = unit
      if (dimName && dimName !== 'dimensionless') {
        if (asHtml) {
          unitStr = `${unit} <span class="dim-name">{${dimName}}</span>`
        }
        unitStrPlain = `${unit} {${dimName}}`
      }

      // Format numbers with appropriate precision
      const meanFmt = formatWithUncertainty(mean, uncertainty)
      const medianFmt = formatWithUncertainty(median, uncertainty)
      const p16Fmt = formatWithUncertainty(p16, uncertainty)
      const p84Fmt = formatWithUncertainty(p84, uncertainty)

      if (asHtml) {
        return `Mean: ${meanFmt} ${unitStr}<br>Median: ${medianFmt} ${unit}<br>[68% CI]: [${p16Fmt}, ${p84Fmt}] ${unit}`
      }

      return `Mean: ${meanFmt} ${unitStrPlain}
Median: ${medianFmt} ${unit}
[68% CI]: [${p16Fmt}, ${p84Fmt}] ${unit}`
    }

    function escapeHtml(str) {
      return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
    }

    // =====================
    // Evaluation
    // =====================

    function runCell(id) {
      const cell = cells.find(c => c.id === id)
      if (!cell || !cell.code.trim()) {
        if (cell) {
          cell.result = null
          cell.error = null
          renderOutput(cell)
        }
        return
      }

      try {
        const result = parse(cell.code, evaluator)
        cell.result = result
        cell.error = null
      } catch (err) {
        cell.result = null
        cell.error = err.message
      }

      renderOutput(cell)
      saveToStorage()
    }

    function runAllCells() {
      // Reset evaluator to clear variables, then run in order
      evaluator.reset()
      for (const cell of cells) {
        if (cell.code.trim()) {
          try {
            const result = parse(cell.code, evaluator)
            cell.result = result
            cell.error = null
          } catch (err) {
            cell.result = null
            cell.error = err.message
          }
          renderOutput(cell)
        }
      }
      saveToStorage()
      setStatus('All cells evaluated')
    }

    // =====================
    // Storage
    // =====================

    function saveToStorage() {
      const data = cells.map(c => ({ id: c.id, code: c.code }))
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data))
    }

    function loadFromStorage() {
      try {
        const data = JSON.parse(localStorage.getItem(STORAGE_KEY))
        if (Array.isArray(data) && data.length > 0) {
          data.forEach(item => {
            createCell(item.code, item.id)
          })
          // Hide examples if we have saved cells
          if (cells.length > 0) {
            examplesBanner.style.display = 'none'
          }
          // Run all to restore state
          runAllCells()
          return true
        }
      } catch (e) {}
      return false
    }

    function clearNotebook() {
      if (!confirm('Clear all cells?')) return
      cells = []
      cellsContainer.innerHTML = ''
      evaluator.reset()
      localStorage.removeItem(STORAGE_KEY)
      window.location.hash = ''
      createCell()
      examplesBanner.style.display = 'block'
      setStatus('Notebook cleared')
    }

    // =====================
    // URL Hash Sharing
    // =====================

    function encodeNotebook() {
      const data = cells.map(c => c.code).filter(c => c.trim())
      if (data.length === 0) return ''
      const json = JSON.stringify(data)
      // Use base64 encoding for URL safety
      return btoa(encodeURIComponent(json))
    }

    function decodeNotebook(hash) {
      if (!hash) return null
      try {
        const json = decodeURIComponent(atob(hash))
        const data = JSON.parse(json)
        if (Array.isArray(data) && data.every(c => typeof c === 'string')) {
          return data
        }
      } catch (e) {}
      return null
    }

    function loadFromHash() {
      const hash = window.location.hash.slice(1)
      if (!hash) return false

      const codes = decodeNotebook(hash)
      if (!codes || codes.length === 0) return false

      // Clear existing cells
      cells = []
      cellsContainer.innerHTML = ''
      evaluator.reset()

      // Create cells from hash
      codes.forEach(code => createCell(code))
      examplesBanner.style.display = 'none'

      // Run all cells
      runAllCells()
      setStatus('Loaded from shared link')
      return true
    }

    function shareNotebook() {
      const encoded = encodeNotebook()
      if (!encoded) {
        setStatus('Nothing to share')
        return
      }

      const url = `${window.location.origin}${window.location.pathname}#${encoded}`

      // Update URL without reload
      window.history.replaceState(null, '', `#${encoded}`)

      // Copy to clipboard
      navigator.clipboard.writeText(url).then(() => {
        setStatus('Link copied to clipboard!')
      }).catch(() => {
        // Fallback: show URL in prompt
        prompt('Share this link:', url)
        setStatus('Link ready to share')
      })
    }

    // =====================
    // Export
    // =====================

    function exportNotebook(format) {
      const data = cells.filter(c => c.code.trim())
      if (data.length === 0) {
        setStatus('Nothing to export')
        return
      }

      let content, filename, mimeType

      switch (format) {
        case 'text':
          content = exportAsText(data)
          filename = 'neofermi-notebook.txt'
          mimeType = 'text/plain'
          break
        case 'markdown':
          content = exportAsMarkdown(data)
          filename = 'neofermi-notebook.md'
          mimeType = 'text/markdown'
          break
        case 'json':
          content = exportAsJSON(data)
          filename = 'neofermi-notebook.json'
          mimeType = 'application/json'
          break
        default:
          return
      }

      downloadFile(content, filename, mimeType)
      setStatus(`Exported as ${format}`)
    }

    function exportAsText(data) {
      return data.map((cell, i) => {
        let output = `[${i + 1}] ${cell.code}`
        if (cell.result) {
          const q = cell.result
          if (q.isDistribution?.()) {
            const qSI = q.toSI ? q.toSI() : q
            output += `\n    => ${formatQuantity(q, false)}`
          } else if (q.isScalar?.()) {
            const qSI = q.toSI ? q.toSI() : q
            output += `\n    => ${cleanFloatArtifacts(qSI.value)} ${qSI.unit.toString()}`
          }
        } else if (cell.error) {
          output += `\n    Error: ${cell.error}`
        }
        return output
      }).join('\n\n')
    }

    function exportAsMarkdown(data) {
      let md = '# NeoFermi Notebook\n\n'
      data.forEach((cell, i) => {
        md += '```neofermi\n' + cell.code + '\n```\n\n'
        if (cell.result) {
          const q = cell.result
          if (q.isDistribution?.()) {
            md += `**Result:** ${formatQuantity(q, false).replace(/\n/g, ' | ')}\n\n`
          } else if (q.isScalar?.()) {
            const qSI = q.toSI ? q.toSI() : q
            md += `**Result:** ${cleanFloatArtifacts(qSI.value)} ${qSI.unit.toString()}\n\n`
          }
        } else if (cell.error) {
          md += `**Error:** ${cell.error}\n\n`
        }
      })
      return md
    }

    function exportAsJSON(data) {
      const exportData = data.map((cell, i) => {
        const entry = {
          index: i + 1,
          code: cell.code,
        }
        if (cell.result) {
          const q = cell.result
          if (q.isDistribution?.()) {
            const qSI = q.toSI ? q.toSI() : q
            entry.result = {
              type: 'distribution',
              mean: qSI.mean(),
              median: qSI.median(),
              p16: qSI.percentile(0.16),
              p84: qSI.percentile(0.84),
              unit: qSI.unit.toString(),
            }
          } else if (q.isScalar?.()) {
            const qSI = q.toSI ? q.toSI() : q
            entry.result = {
              type: 'scalar',
              value: qSI.value,
              unit: qSI.unit.toString(),
            }
          }
        } else if (cell.error) {
          entry.error = cell.error
        }
        return entry
      })
      return JSON.stringify(exportData, null, 2)
    }

    function downloadFile(content, filename, mimeType) {
      const blob = new Blob([content], { type: mimeType })
      const url = URL.createObjectURL(blob)
      const a = document.createElement('a')
      a.href = url
      a.download = filename
      document.body.appendChild(a)
      a.click()
      document.body.removeChild(a)
      URL.revokeObjectURL(url)
    }

    // =====================
    // Import
    // =====================

    function importNotebook(file) {
      const reader = new FileReader()
      reader.onload = (e) => {
        const content = e.target.result
        const ext = file.name.split('.').pop().toLowerCase()

        let codes = []
        try {
          if (ext === 'json') {
            codes = importFromJSON(content)
          } else if (ext === 'md') {
            codes = importFromMarkdown(content)
          } else {
            codes = importFromText(content)
          }
        } catch (err) {
          setStatus(`Import error: ${err.message}`)
          return
        }

        if (codes.length === 0) {
          setStatus('No code found in file')
          return
        }

        // Clear existing and create new cells
        cells = []
        cellsContainer.innerHTML = ''
        evaluator.reset()

        codes.forEach(code => createCell(code))
        examplesBanner.style.display = 'none'
        runAllCells()
        setStatus(`Imported ${codes.length} cell${codes.length > 1 ? 's' : ''}`)
      }
      reader.readAsText(file)
    }

    function importFromJSON(content) {
      const data = JSON.parse(content)
      if (Array.isArray(data)) {
        // Could be [{code: ...}, ...] or ["code", "code", ...]
        return data.map(item => typeof item === 'string' ? item : item.code).filter(Boolean)
      }
      return []
    }

    function importFromMarkdown(content) {
      // Extract code from ```neofermi or ``` blocks
      const codeBlockRegex = /```(?:neofermi)?\s*\n([\s\S]*?)```/g
      const codes = []
      let match
      while ((match = codeBlockRegex.exec(content)) !== null) {
        const code = match[1].trim()
        if (code) codes.push(code)
      }
      return codes
    }

    function importFromText(content) {
      // Split by blank lines or [n] markers
      const lines = content.split('\n')
      const codes = []
      let currentCode = []

      for (const line of lines) {
        // Check for cell marker like [1], [2], etc.
        if (/^\s*\[\d+\]/.test(line)) {
          if (currentCode.length > 0) {
            codes.push(currentCode.join('\n').trim())
            currentCode = []
          }
          // Extract code after the marker
          const code = line.replace(/^\s*\[\d+\]\s*/, '')
          if (code) currentCode.push(code)
        } else if (line.trim().startsWith('=>') || line.trim().startsWith('Error:')) {
          // Skip result lines
          continue
        } else if (line.trim() === '' && currentCode.length > 0) {
          codes.push(currentCode.join('\n').trim())
          currentCode = []
        } else if (line.trim()) {
          currentCode.push(line)
        }
      }

      if (currentCode.length > 0) {
        codes.push(currentCode.join('\n').trim())
      }

      return codes.filter(c => c)
    }

    // =====================
    // Status
    // =====================

    function updateStatus() {
      const count = cells.length
      statusEl.textContent = `${count} cell${count !== 1 ? 's' : ''}`
    }

    function setStatus(msg) {
      statusEl.textContent = msg
      setTimeout(updateStatus, 2000)
    }

    // =====================
    // Event Handlers
    // =====================

    addCellBtn.addEventListener('click', () => {
      const cell = createCell()
      // Focus the new cell
      setTimeout(() => {
        const textarea = document.querySelector(`#cell-${cell.id} .cell-input`)
        textarea?.focus()
      }, 50)
    })

    document.getElementById('run-all-btn').addEventListener('click', runAllCells)
    document.getElementById('clear-btn').addEventListener('click', clearNotebook)
    document.getElementById('share-btn').addEventListener('click', shareNotebook)

    // Import
    const importBtn = document.getElementById('import-btn')
    const importFile = document.getElementById('import-file')

    importBtn.addEventListener('click', () => {
      importFile.click()
    })

    importFile.addEventListener('change', (e) => {
      const file = e.target.files[0]
      if (file) {
        importNotebook(file)
        importFile.value = '' // Reset for next import
      }
    })

    // Export dropdown
    const exportBtn = document.getElementById('export-btn')
    const exportMenu = document.getElementById('export-menu')

    exportBtn.addEventListener('click', (e) => {
      e.stopPropagation()
      exportMenu.classList.toggle('visible')
    })

    document.querySelectorAll('.export-option').forEach(option => {
      option.addEventListener('click', (e) => {
        e.stopPropagation()
        const format = option.dataset.format
        exportNotebook(format)
        exportMenu.classList.remove('visible')
      })
    })

    // Close export menu when clicking outside
    document.addEventListener('click', () => {
      exportMenu.classList.remove('visible')
    })

    // Help modal
    document.getElementById('help-btn').addEventListener('click', () => {
      document.getElementById('help-modal').classList.add('visible')
    })
    document.getElementById('close-help').addEventListener('click', () => {
      document.getElementById('help-modal').classList.remove('visible')
    })
    document.getElementById('help-modal').addEventListener('click', (e) => {
      if (e.target.classList.contains('modal-overlay')) {
        document.getElementById('help-modal').classList.remove('visible')
      }
    })

    // Viz toggle
    document.querySelectorAll('[data-viz]').forEach(btn => {
      btn.addEventListener('click', () => {
        vizType = btn.dataset.viz
        document.querySelectorAll('[data-viz]').forEach(b => b.classList.remove('active'))
        btn.classList.add('active')
        // Re-render all outputs with new viz type
        cells.forEach(cell => {
          if (cell.result && cell.result.isDistribution?.()) {
            renderOutput(cell)
          }
        })
      })
    })

    // Example chips
    document.querySelectorAll('.example-chip').forEach(chip => {
      chip.addEventListener('click', () => {
        const code = chip.dataset.code
        // Add to first empty cell or create new cell
        let targetCell = cells.find(c => !c.code.trim())
        if (!targetCell) {
          targetCell = createCell(code)
        } else {
          targetCell.code = code
          const textarea = document.querySelector(`#cell-${targetCell.id} .cell-input`)
          if (textarea) {
            textarea.value = code
            textarea.dispatchEvent(new Event('input'))
          }
        }
        runCell(targetCell.id)
        examplesBanner.style.display = 'none'
      })
    })

    // =====================
    // Keyboard Shortcuts
    // =====================

    document.addEventListener('keydown', (e) => {
      // Ctrl/Cmd + Enter: Run all cells
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault()
        runAllCells()
        return
      }

      // Ctrl/Cmd + S: Export as JSON
      if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault()
        exportNotebook('json')
        return
      }

      // Ctrl/Cmd + O: Import
      if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
        e.preventDefault()
        importFile.click()
        return
      }

      // Ctrl/Cmd + N: New cell
      if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
        e.preventDefault()
        const cell = createCell()
        setTimeout(() => {
          document.querySelector(`#cell-${cell.id} .cell-input`)?.focus()
        }, 50)
        return
      }

      // Escape: Blur current input
      if (e.key === 'Escape') {
        document.activeElement?.blur()
        return
      }
    })

    // =====================
    // Initialize
    // =====================

    // Priority: URL hash > localStorage > empty notebook
    if (!loadFromHash() && !loadFromStorage()) {
      createCell()
    }
    updateStatus()
  </script>
</body>
</html>
